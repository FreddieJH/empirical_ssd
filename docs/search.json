[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Background information",
    "section": "",
    "text": "Giometto et al. (2013) used an experimental set up of 13 protist species to show that body size (volume, \\(\\micro m\\)) for each species could be described by a single parameter value, mean body size. When normalising observed body size to the mean body size of the species, all 13 species showed a similar pattern in their body size distributions (Figure 1).\n\n\n\nFigure 1: Protist body size distributions can be described by a single parameter; mean body size. n = 13 species. Figure taken from Giometto et al. (2013).\n\n\nThis leads us to the questions:\n\nDoes this pattern hold for fish species?\nIs the pattern really that interesting? I.e. due to the log-log axis and the scaling, is the variation in the tails of the distribution really where the distributions differ? In other words, does the $\\sigma^2$ parameter of the lognormal distribution really not matter in determining the overall species body size distribution?\nDoes a lognormal distribution fit well to the observed data?\nCan we find another distribution that fits better than the lognormal? or add a parameter to the lognormal distribution to account for the ‘deviation’ from lognormal?\nWhat is the minimum number of parameters required to fit a distribution to the empirical data that encompasses both the shape and some measure of skewness (maybe a proxy for disturbance)."
  },
  {
    "objectID": "n3_spp_system.html",
    "href": "n3_spp_system.html",
    "title": "Starting simple",
    "section": "",
    "text": "We want to chose three fish species from the RLS dataset. These species should ideally be non-target species for fisheries, should cover multiple size classes, and should be relatively abundant.\nFishing pressure data are taken from supplementary table 1 of Audzijonyte et al. (2020).\n\nlibrary(tidyverse)\n\n\nnontarget_spp <- \n  read_csv(\"data/audzijonyte_nee_supplementary_table_1_fishing.csv\") |> \n  filter(fisheries_target == \"rarely\") |> \n  pull(species)\n\nhead(nontarget_spp)\n\n[1] \"Abudefduf bengalensis\"         \"Abudefduf sexfasciatus\"       \n[3] \"Abudefduf vaigiensis\"          \"Abudefduf whitleyi\"           \n[5] \"Acanthaluteres spilomelanurus\" \"Acanthochromis polyacanthus\""
  },
  {
    "objectID": "shane_jervisbay.html",
    "href": "shane_jervisbay.html",
    "title": "Are length distributions within species normal or log-normal?",
    "section": "",
    "text": "Note: For this script to work, you must be using R version older than 4.2. This is because Rstan has problems with Rv4.2+.\n\n\n\nlibrary(tidyverse)\nlibrary(ggrepel)\nlibrary(rstan)\nlibrary(bayesplot)\nlibrary(cowplot)\nlibrary(RColorBrewer)\n\ndf_single <- read_csv(\"data/JBMP_S3_clean.csv\") # read in individual lengths\n\n\n\n\n\n# create a vector of bin length boundaries\ncutoff = c(2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 50, \n  seq(from=62.5, to=200, by=12.5), \n  seq(from=250, to=500, by=50))\nrls_bins = c(0, cutoff)\n\n# create a data frame that links fish lengths with bin indices\ndf_cutoff <- tibble(\n  size_class = cutoff,\n  size_indx = 1:length(cutoff)\n)\n\n# add bin indices to the dataset\ndf_single <- left_join(df_single, df_cutoff, by = \"size_class\")\n\n# calculate species counts and mean species lengths\ndf_abundance <- df_single %>%\n  group_by(spp_id) %>%\n  summarise(.groups = \"drop\", Total_N = n(), Mean_L = mean(size_class))\n\n# group counts of same species of same size \ndf_fit <- df_single %>%\n  group_by(spp_id, size_indx, w) %>%\n  summarise(.groups = \"drop\", n = n()) %>%   # calc fish in bin\n  left_join(df_cutoff, by = \"size_indx\") %>% # add size class info\n  left_join(df_abundance, by = \"spp_id\") %>% # add species abundances\n    mutate(f_obs = n/Total_N) # calc fraction of individuals in size class\n\nglimpse(df_fit) # show info used when fitting\n\nRows: 405\nColumns: 8\n$ spp_id     <dbl> 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,~\n$ size_indx  <int> 9, 10, 8, 10, 11, 12, 7, 8, 9, 10, 6, 7, 8, 9, 10, 11, 12, ~\n$ w          <dbl> 987.990211, 1539.425071, 242.365409, 666.461935, 995.672563~\n$ n          <int> 1, 1, 1, 2, 2, 2, 4, 2, 2, 1, 2, 7, 11, 13, 10, 11, 11, 7, ~\n$ size_class <dbl> 30.0, 35.0, 25.0, 35.0, 40.0, 50.0, 20.0, 25.0, 30.0, 35.0,~\n$ Total_N    <int> 2, 2, 7, 7, 7, 7, 9, 9, 9, 9, 76, 76, 76, 76, 76, 76, 76, 7~\n$ Mean_L     <dbl> 32.50000, 32.50000, 39.28571, 39.28571, 39.28571, 39.28571,~\n$ f_obs      <dbl> 0.50000000, 0.50000000, 0.14285714, 0.28571429, 0.28571429,~"
  },
  {
    "objectID": "shane_jervisbay.html#data-plots",
    "href": "shane_jervisbay.html#data-plots",
    "title": "Are length distributions within species normal or log-normal?",
    "section": "Data plots",
    "text": "Data plots\n\ndf_plot <- df_fit %>% filter(Total_N > 20) # limit plot to abundant species\nspp_plotted <- sort(unique(df_plot$spp_id)) # species plotted\n\nggplot(data = df_plot) + \n    geom_point(mapping = aes(x = size_class, y = n)) + \n    geom_line(mapping = aes(x = size_class, y = n)) +\n    facet_wrap( ~ spp_id, ncol = 5) +\n    scale_y_log10() + scale_x_log10() +\n    labs(x = \"Fish length (cm)\",  y = \"Fish abundance\") +\n    theme_bw()\n\n\n\n\n\nggplot(df_plot) + # limit to abundant species\n    geom_point(mapping = aes(x = size_class, y = n)) + \n    geom_line(mapping = aes(x = size_class, y = n)) +\n    facet_wrap( ~ spp_id, ncol = 5) +\n    scale_y_log10() + \n    labs(x = \"Fish length (cm)\",y = \"Fish abundance\") +\n    theme_bw()\n\n\n\n\n\nggplot(data = df_abundance, \n      aes(x = Mean_L, y = Total_N, label = spp_id)) +\n    geom_point(color = \"red\") + \n    # geom_text_repel(size = 2.5) +\n    labs(x = \"Observed mean fish length (cm)\", y =\"Abundance\") +\n    scale_y_log10() + scale_x_log10() + \n    theme_bw()"
  },
  {
    "objectID": "shane_jervisbay.html#bayesian-model-fit",
    "href": "shane_jervisbay.html#bayesian-model-fit",
    "title": "Are length distributions within species normal or log-normal?",
    "section": "Bayesian Model Fit",
    "text": "Bayesian Model Fit\n\nI <- nrow(df_fit)          # daily observations\nB <- max(df_fit$size_indx) # maximum bin group\nS <- max(df_fit$spp_id) # maximum bin group\n\nstan_dat <- list(\n  I = I, # number of observations\n    S = S, # number od species\n    B = B, # number of bins\n    l = cutoff[1:B], # length cut-offs\n    s = df_fit$spp_id, # species\n    b = df_fit$size_indx, # length bin\n    n = df_fit$n) # individual counts    \n\nglimpse(stan_dat) # show data fed to rstan\n\nList of 7\n $ I: int 405\n $ S: num 108\n $ B: int 25\n $ l: num [1:25] 2.5 5 7.5 10 12.5 15 20 25 30 35 ...\n $ s: num [1:405] 1 1 2 2 2 2 3 3 3 3 ...\n $ b: int [1:405] 9 10 8 10 11 12 7 8 9 10 ...\n $ n: int [1:405] 1 1 1 2 2 2 4 2 2 1 ...\n\n\n\n# fit the normal pdf model!\nfit_n <- \n  stan(\n    file = \"data/stan_models/NormalFit.stan\", \n    data = stan_dat,\n    iter = 400, \n    warmup = 200, \n    chains = 3, \n    refresh = 200, \n    seed = 1, \n  )\n\n\nSAMPLING FOR MODEL 'NormalFit' NOW (CHAIN 1).\nChain 1: Rejecting initial value:\nChain 1:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 1:   Stan can't start sampling from this initial value.\nChain 1: Rejecting initial value:\nChain 1:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 1:   Stan can't start sampling from this initial value.\nChain 1: Rejecting initial value:\nChain 1:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 1:   Stan can't start sampling from this initial value.\nChain 1: Rejecting initial value:\nChain 1:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 1:   Stan can't start sampling from this initial value.\nChain 1: Rejecting initial value:\nChain 1:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 1:   Stan can't start sampling from this initial value.\nChain 1: Rejecting initial value:\nChain 1:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 1:   Stan can't start sampling from this initial value.\nChain 1: Rejecting initial value:\nChain 1:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 1:   Stan can't start sampling from this initial value.\nChain 1: Rejecting initial value:\nChain 1:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 1:   Stan can't start sampling from this initial value.\nChain 1: Rejecting initial value:\nChain 1:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 1:   Stan can't start sampling from this initial value.\nChain 1: Rejecting initial value:\nChain 1:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 1:   Stan can't start sampling from this initial value.\nChain 1: \nChain 1: Gradient evaluation took 0 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:   1 / 400 [  0%]  (Warmup)\nChain 1: Iteration: 200 / 400 [ 50%]  (Warmup)\nChain 1: Iteration: 201 / 400 [ 50%]  (Sampling)\nChain 1: Iteration: 400 / 400 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 3.617 seconds (Warm-up)\nChain 1:                0.695 seconds (Sampling)\nChain 1:                4.312 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL 'NormalFit' NOW (CHAIN 2).\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: Rejecting initial value:\nChain 2:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 2:   Stan can't start sampling from this initial value.\nChain 2: \nChain 2: Gradient evaluation took 0 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:   1 / 400 [  0%]  (Warmup)\nChain 2: Iteration: 200 / 400 [ 50%]  (Warmup)\nChain 2: Iteration: 201 / 400 [ 50%]  (Sampling)\nChain 2: Iteration: 400 / 400 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 3.38 seconds (Warm-up)\nChain 2:                0.801 seconds (Sampling)\nChain 2:                4.181 seconds (Total)\nChain 2: \n\nSAMPLING FOR MODEL 'NormalFit' NOW (CHAIN 3).\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: Rejecting initial value:\nChain 3:   Log probability evaluates to log(0), i.e. negative infinity.\nChain 3:   Stan can't start sampling from this initial value.\nChain 3: \nChain 3: Gradient evaluation took 0 seconds\nChain 3: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 3: Adjust your expectations accordingly!\nChain 3: \nChain 3: \nChain 3: Iteration:   1 / 400 [  0%]  (Warmup)\nChain 3: Iteration: 200 / 400 [ 50%]  (Warmup)\nChain 3: Iteration: 201 / 400 [ 50%]  (Sampling)\nChain 3: Iteration: 400 / 400 [100%]  (Sampling)\nChain 3: \nChain 3:  Elapsed Time: 4.089 seconds (Warm-up)\nChain 3:                0.728 seconds (Sampling)\nChain 3:                4.817 seconds (Total)\nChain 3: \n\n\n\n# check out some predicted model parameters and log-likelihood\nmodel_par <- c(\"lp__\", \"ln_cv\", \"ln_mu[66]\", \"ln_mu[4]\", \"ln_mu[44]\")\n\n# check for chain convergence\nrstan::traceplot(object = fit_n, pars = model_par, inc_warmup = TRUE, ncol = 5)\n\n\n\n\n\nModel predictions\n\n# calculate the predicted mean length of each species and 90% credible interval\nl_par <- rstan::extract(fit_n, pars = c(\"ln_cv\", \"ln_mu\"))\n\ndf_pred_spp <- tibble(Spp = 1:S) # create a data frame\n# add quantiles of predicted mean fish lengths\ndf_pred_spp$medn = exp(apply(X = l_par$ln_mu, MARGIN = 2, FUN = quantile, \n probs = 0.5))\ndf_pred_spp$lwr90 = exp(apply(X = l_par$ln_mu, MARGIN = 2, FUN = quantile, \n  probs = 0.05))\ndf_pred_spp$upp90 = exp(apply(X = l_par$ln_mu, MARGIN = 2, FUN = quantile, \n  probs = 0.95))\n\nggplot(df_pred_spp) +\n    geom_errorbar(aes(x = Spp, ymin = lwr90, ymax = upp90), width = 0.2) +\n    geom_point(aes(x =Spp, y = medn)) +\n    labs(x = \"Species id\", y = \"Mean length (cm)\", subtitle = \"Bars = 90%CI for mean\") +\n    theme_bw()\n\n\n\n\n\n# for each species and bin size predict probability of fish being in the bin\ndf_predict <- expand_grid(\n    spp_id = 1:S, size_indx = 1:B)\ndf_predict$p_n = 0.0 # create a column\n\nfor (i in 1:nrow(df_predict)) {\n  if (df_predict$size_indx[i] == 1) { # special case for smallest bin\n    p_all <- pnorm(cutoff[1], mean = exp(l_par$ln_mu[ ,df_predict$spp_id[i]]), \n      sd = exp(l_par$ln_mu[ ,df_predict$spp_id[i]])*exp(l_par$ln_cv))\n  } else { # larger bins\n    p_all <- pnorm(cutoff[df_predict$size_indx[i]], mean = exp(l_par$ln_mu[ ,df_predict$spp_id[i]]), \n      sd = exp(l_par$ln_mu[ ,df_predict$spp_id[i]])*exp(l_par$ln_cv)) -\n        pnorm(cutoff[df_predict$size_indx[i]-1], mean = exp(l_par$ln_mu[ ,df_predict$spp_id[i]]), \n      sd = exp(l_par$ln_mu[ ,df_predict$spp_id[i]])*exp(l_par$ln_cv))\n  }\n  df_predict$p_n[i] <- mean(p_all) # store the mean predicted probability\n}\n\ndf_predict <- left_join(df_predict, df_cutoff, by = \"size_indx\") # add bin sizes\n\n\nggplot() +\n    geom_point(data = filter(df_predict, spp_id %in% spp_plotted), aes(x = size_class, y = p_n), color = \"red\", size = 1) +\n    geom_line(data = filter(df_predict, spp_id %in% spp_plotted), aes(x = size_class, y = p_n), color = \"red\") +\n    geom_point(data = filter(df_fit, spp_id %in% spp_plotted), aes(x = size_class, y = f_obs), color= \"black\", size = 2) +\n    facet_wrap( ~ spp_id, ncol = 5) +\n    labs(x = \"Size class (cm)\", y = \"Probability\") +\n    theme_bw()\n\n\n\n\n\n# fit the log-normal pdf model!\nfit_ln <- stan(file = 'data/stan_models/LogNormalFit.stan', data = stan_dat,\n  iter = 400, warmup = 200, chains = 3, refresh = 200)\n\n\nSAMPLING FOR MODEL 'LogNormalFit' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 0.001 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 10 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:   1 / 400 [  0%]  (Warmup)\nChain 1: Iteration: 200 / 400 [ 50%]  (Warmup)\nChain 1: Iteration: 201 / 400 [ 50%]  (Sampling)\nChain 1: Iteration: 400 / 400 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 2.556 seconds (Warm-up)\nChain 1:                0.934 seconds (Sampling)\nChain 1:                3.49 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL 'LogNormalFit' NOW (CHAIN 2).\nChain 2: \nChain 2: Gradient evaluation took 0 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:   1 / 400 [  0%]  (Warmup)\nChain 2: Iteration: 200 / 400 [ 50%]  (Warmup)\nChain 2: Iteration: 201 / 400 [ 50%]  (Sampling)\nChain 2: Iteration: 400 / 400 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 2.338 seconds (Warm-up)\nChain 2:                0.79 seconds (Sampling)\nChain 2:                3.128 seconds (Total)\nChain 2: \n\nSAMPLING FOR MODEL 'LogNormalFit' NOW (CHAIN 3).\nChain 3: \nChain 3: Gradient evaluation took 0 seconds\nChain 3: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 3: Adjust your expectations accordingly!\nChain 3: \nChain 3: \nChain 3: Iteration:   1 / 400 [  0%]  (Warmup)\nChain 3: Iteration: 200 / 400 [ 50%]  (Warmup)\nChain 3: Iteration: 201 / 400 [ 50%]  (Sampling)\nChain 3: Iteration: 400 / 400 [100%]  (Sampling)\nChain 3: \nChain 3:  Elapsed Time: 1.912 seconds (Warm-up)\nChain 3:                0.656 seconds (Sampling)\nChain 3:                2.568 seconds (Total)\nChain 3: \n\n\n\n# check out some predicted model parameters and log-likelihood\nmodel_par <- c(\"lp__\", \"ln_sigma\", \"ln_mu[66]\", \"ln_mu[4]\", \"ln_mu[44]\")\n\n# check for chain convergence\nrstan::traceplot(object = fit_ln, pars = model_par, inc_warmup = TRUE, ncol = 5)\n\n\n\n\n\n# calculate the predicted mean length of each species and 90% credible interval\nl_par <- rstan::extract(fit_ln, pars = c(\"ln_sigma\", \"ln_mu\"))\n\ndf_pred_spp <- tibble(Spp = 1:S) # create a data frame\n# add quantiles of predicted mean fish lengths\ndf_pred_spp$medn = exp(apply(X = l_par$ln_mu, MARGIN = 2, FUN = quantile, \n probs = 0.5))\ndf_pred_spp$lwr90 = exp(apply(X = l_par$ln_mu, MARGIN = 2, FUN = quantile, \n  probs = 0.05))\ndf_pred_spp$upp90 = exp(apply(X = l_par$ln_mu, MARGIN = 2, FUN = quantile, \n  probs = 0.95))\n\nggplot(df_pred_spp) +\n    geom_errorbar(aes(x = Spp, ymin = lwr90, ymax = upp90), width = 0.2) +\n    geom_point(aes(x =Spp, y = medn)) +\n    labs(\n    x = \"Species id\", \n    y = \"Median length (cm)\", \n    subtitle = \"Bars = 90%CI for median\") +\n    theme_bw()\n\n\n\n\n\n# for each species and bin size predict probability of fish being in the bin\ndf_predict$p_ln = 0.0 # create a column\n\nfor (i in 1:nrow(df_predict)) {\n  if (df_predict$size_indx[i] == 1) { # special case for smallest bin\n    p_all <- plnorm(cutoff[1], meanlog = l_par$ln_mu[ ,df_predict$spp_id[i]], \n      sdlog = exp(l_par$ln_sigma))\n  } else { # larger bins\n    p_all <- plnorm(cutoff[df_predict$size_indx[i]], meanlog = l_par$ln_mu[\n        ,df_predict$spp_id[i]], sdlog = exp(l_par$ln_sigma)) -\n        plnorm(cutoff[df_predict$size_indx[i]-1], meanlog = l_par$ln_mu[\n        ,df_predict$spp_id[i]], sdlog = exp(l_par$ln_sigma))\n  }\n  df_predict$p_ln[i] <- mean(p_all) # store the mean predicted probability\n}\n\n\nggplot() +\n    geom_point(data = filter(df_predict, spp_id %in% spp_plotted), aes(x = size_class, y = p_ln), color = \"purple\", size = 1) +\n    geom_line(data = filter(df_predict, spp_id %in% spp_plotted), aes(x = size_class, y = p_ln), color = \"purple\") +\n    geom_point(data = filter(df_fit, spp_id %in% spp_plotted), aes(x = size_class, y = f_obs), color= \"black\", size = 2) +\n    facet_wrap( ~ spp_id, ncol = 5) +\n    labs(x = \"Size class (cm)\", y = \"Probability\") +\n    theme_bw()\n\n\n\n\n\nggplot() +\n    geom_point(data = filter(df_predict, spp_id %in% spp_plotted, p_n > 0.001), \n        aes(x = size_class, y = p_n), color = \"red\", size = 1) +\n    geom_line(data = filter(df_predict, spp_id %in% spp_plotted, p_n > 0.001), \n        aes(x = size_class, y = p_n), color = \"red\") +\n    geom_point(data = filter(df_predict, spp_id %in% spp_plotted, p_ln > 0.001), \n        aes(x = size_class, y = p_ln), color = \"purple\", size = 1) +\n    geom_line(data = filter(df_predict, spp_id %in% spp_plotted, p_ln > 0.001), \n        aes(x = size_class, y = p_ln), color = \"purple\") +\n    geom_point(data = filter(df_fit, spp_id %in% spp_plotted), \n        aes(x = size_class, y = f_obs), color= \"black\", size = 2) +\n    scale_x_log10() + scale_y_log10() +\n    labs(caption = \"Black = observed fractions, red/purple is predicted fractions if normally/log-normally distributed and all species have the same coeff. of variation.\") +\n    facet_wrap( ~ spp_id, ncol = 5) +\n    labs(x = \"Size class (cm)\", y = \"Probability\") +\n    theme_bw()\n\n\n\n\n\nll_ln <- rstan::extract(fit_ln, pars = c(\"lp__\"))\nmean(ll_ln$lp__) # log-likelihood of log-normal assumption\n\n[1] -3555.827\n\n\n\nll_n <- rstan::extract(fit_n, pars = c(\"lp__\"))\nmean(ll_n$lp__) # log-likelihood of log-normal assumption\n\n[1] -3475.385\n\n\n\nnormal wins!"
  }
]